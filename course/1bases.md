# Глава 1: Введение в Pygame

Добро пожаловать в мир создания игр с Pygame! В этой главе мы познакомимся с основами этой мощной библиотеки, необходимыми для начала вашего творческого пути. 

### 1.1 Что такое Pygame?

Pygame - это свободная и открытая библиотека для создания игр, работающая с Python. Она предоставляет набор инструментов, упрощающих разработку различных игр, от простых аркад до сложных RPG. 

### 1.2. Установка Pygame:

Прежде чем мы начнем писать код, необходимо установить Pygame. Самый простой способ сделать это - использовать pip, менеджер пакетов Python:

```bash
pip install pygame
```

### 1.3. Инициализация Pygame:

Перед запуском любой игры нам нужно инициализировать Pygame. 

`pygame.init()` нужен для инициализации всех модулей Pygame, которые используются в игре. Без этой команды модули, такие как звук, графика или обработка событий, могут работать некорректно или не запускаться вовсе. Это обязательный шаг для подготовки библиотеки перед использованием её возможностей.

Инициализация производиться с помощью функции pygame.init():

```python
import pygame

pygame.init()
```

### 1.4. Окно игры:

Следующим шагом является создание окна, в котором будет отображаться наша игра. Для этого мы используем функцию pygame.display.set_mode():

```python
screen = pygame.display.set_mode((800, 600))
```

Эта функция создаёт окно для игры размером 800x600 пикселей. Она задаёт размеры и инициализирует экран для отображения графики. Возвращает объект Surface, на котором можно рисовать. Без этого окна игра не сможет отображать визуальные элементы.

_Данный объект screen будет использоваться впоследствии для отрисовки всех изменений на экране_

### 1.5. Игровой цикл:

Сердцем каждой игры является игровой цикл. Он обеспечивает постоянную работу игры, обрабатывает события, обновляет состояние игры и отображает изменения на экране.

Цикл событий обрабатывает множество вещей:
1. Обработка событий: Проверяем, не произошло ли каких-либо событий, например, нажатие клавиши, движение мыши, закрытие окна.
2. Обновление состояния игры: Изменяем состояние игры, например, перемещаем персонажа, проверяем столкновения, обновляем счет.
3. Отрисовка графики: Очищаем экран, рисуем фон, персонажей, объекты и другие элементы игры.
4. Обновление экрана: Перерисовываем весь экран, отображая все изменения, внесенные на предыдущих шагах.

Код ниже является примером создания базового цикла событий

```python
running = True

while running:
  # Обработка событий
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      running = False

  # Обновление состояния игры

  # Отрисовка графики

  # Обновление экрана
  pygame.display.flip()
```

Этот цикл работает бесконечно, пока переменная running равна True.

Тут мы знакомимся с понятием события как объекта в pygame

### 1.5.1 Базовые события

Внутри цикла обработки событий мы можем проверять множество базовых событий, таких как управлением курсора и движение мышью

```python
for event in pygame.event.get():
    if event.type == pygame.QUIT:  # Закрытие окна
        running = False
    elif event.type == pygame.KEYDOWN:  # Нажатие клавиши
        print(f"Клавиша нажата: {pygame.key.name(event.key)}")
    elif event.type == pygame.KEYUP:  # Отпускание клавиши
        print(f"Клавиша отпущена: {pygame.key.name(event.key)}")
    elif event.type == pygame.MOUSEBUTTONDOWN:  # Клик мыши
        print(f"Кнопка мыши нажата: {event.button}, координаты: {event.pos}")
    elif event.type == pygame.MOUSEMOTION:  # Движение мыши
        print(f"Мышь перемещена: {event.pos}")
    elif event.type == pygame.MOUSEBUTTONUP:  # Отпускание кнопки мыши
        print(f"Кнопка мыши отпущена: {event.button}, координаты: {event.pos}")
```

Объекты event, которые мы перебираем в цикле являются объектами событий со своими параметрами, все нужные параметры события такие как координаты курсора и код нажатой кнопки мы можем узнать именно по параметрам объекта, например:

1) pygame.QUIT: Обрабатывается, когда пользователь закрывает окно.
2) pygame.KEYDOWN и pygame.KEYUP: Реагируют на нажатие и отпускание клавиш.
    * event.key возвращает код клавиши.
    * Функция pygame.key.name() преобразует код в строку.
4) pygame.MOUSEBUTTONDOWN и pygame.MOUSEBUTTONUP: Обрабатывают нажатие и отпускание кнопок мыши.
    * event.button возвращает номер кнопки (1 — левая, 2 — средняя, 3 — правая).
    * event.pos возвращает координаты курсора в момент события.
4) pygame.MOUSEMOTION: Реагирует на перемещение курсора.
    * event.pos возвращает текущую позицию курсора.

### 1.5.2 Собственные события

В Pygame можно создавать свои события с помощью механизма пользовательских событий (USEREVENT). Вот как это делается:

Определите код события:
Pygame резервирует диапазон событий начиная с pygame.USEREVENT. Для уникальности можно добавлять к нему числа. Например:

```python
MY_CUSTOM_EVENT = pygame.USEREVENT + 1
```

С помощью таймера мы можем задать переодичность созданного события:

```python
pygame.time.set_timer(MY_CUSTOM_EVENT, 2000) # Таймер для события (каждые 2 секунды)
```

Создайте событие:

Используйте pygame.event.Event или pygame.event.post, чтобы создать и добавить событие в очередь:

```python
event = pygame.event.Event(MY_CUSTOM_EVENT, {"message": "Hello!"})
pygame.event.post(event)
```

Обработайте событие в игровом цикле:
Перехватывайте пользовательские события в основном цикле с помощью pygame.event.get():

```python
for event in pygame.event.get():
    if event.type == MY_CUSTOM_EVENT:
        print(event.message)  # Доступ к данным события
```

В коде ниже мы создаем свое событие, которое исполняется каждые 2 секунды (2000 миллисекунд). Когда происходит это событие мы выводим в терминал текст: "Событие сработало!"

```python
# Пользовательское событие
MY_CUSTOM_EVENT = pygame.USEREVENT + 1

# Таймер для события (каждые 2 секунды)
pygame.time.set_timer(MY_CUSTOM_EVENT, 2000)

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == MY_CUSTOM_EVENT:
            print("Событие сработало!")

    screen.fill((0, 0, 0))
    pygame.display.flip()
    clock.tick(60)
```

### 1.6. Рисование на экране:
Pygame предоставляет широкие возможности для рисования графики на экране. Все рисунки выполняются на объектах типа `Surface` как тот, который мы содавали в пункте 4, которые могут представлять окно игры или отдельные изображения.

#### 1.6.1 Заливка поверхности
Метод fill используется для заливки поверхности определённым цветом.

```python
screen.fill((0, 0, 255))  # Заливка экрана синим цветом
```

#### 1.6.2 Рисование примитивных фигур
Pygame предоставляет функции для рисования геометрических фигур:

1) Прямоугольники
Функция: `pygame.draw.rect(surface, color, rect, width=0)`

 * rect: кортеж (x, y, width, height) или объект pygame.Rect.
 * width: толщина линии (0 для заполненного прямоугольника).

```
pygame.draw.rect(screen, (255, 0, 0), (100, 100, 200, 150), 5)  # Красный прямоугольник с рамкой
pygame.draw.rect(screen, (0, 255, 0), (400, 300, 100, 50))      # Заполненный зелёный прямоугольник
```

2) Круги
Функция: `pygame.draw.circle(surface, color, center, radius, width=0)`

 * center: координаты центра (x, y).
 * radius: радиус круга.

```python
pygame.draw.circle(screen, (255, 255, 0), (400, 300), 50)       # Жёлтый круг
pygame.draw.circle(screen, (0, 0, 255), (200, 150), 75, 5)      # Круг с синей рамкой
```

#### Линии
Функция: `pygame.draw.line(surface, color, start_pos, end_pos, width=1)`

 * start_pos, end_pos: начальная и конечная точки линии.
```python
pygame.draw.line(screen, (255, 255, 255), (50, 50), (750, 550), 3)  # Белая линия
```

#### Ломаные линии
Функция: `pygame.draw.lines(surface, color, closed, pointlist, width=1)`

 * pointlist: список точек (x, y).
 * closed: соединить ли конец с началом.

```python
pygame.draw.lines(screen, (0, 255, 255), False, [(100, 100), (200, 200), (300, 100)], 3)
```

#### Многоугольники
Функция: `pygame.draw.polygon(surface, color, pointlist, width=0)`

 * pointlist: список вершин.

```python
pygame.draw.polygon(screen, (255, 0, 255), [(300, 300), (400, 500), (200, 500)])  # Заполненный треугольник
```

#### Эллипсы
Функция: `pygame.draw.ellipse(surface, color, rect, width=0)`

 * rect: область, внутри которой рисуется эллипс.

```python
pygame.draw.ellipse(screen, (0, 255, 0), (300, 200, 200, 100))  # Зелёный эллипс
```

#### Дуги
Функция: `pygame.draw.arc(surface, color, rect, start_angle, end_angle, width=1)`

 * Угол указывается в радианах.

```python
pygame.draw.arc(screen, (255, 0, 0), (100, 100, 200, 200), 0, 3.14, 5)  # Красная дуга
```

3) Работа с изображениями
Загрузка изображений: pygame.image.load('path/to/image.png')
Отображение на экране: blit
python
Копировать код
image = pygame.image.load('example.png')
screen.blit(image, (100, 100))
4) Рисование текста
Создание шрифта:

```python
font = pygame.font.Font(None, 36)  # Стандартный шрифт, размер 36
```

Рендеринг текста:

```python
text_surface = font.render("Привет, Pygame!", True, (255, 255, 255))  # Белый текст
```

Отображение текста:

```python
screen.blit(text_surface, (100, 100))
```

6) Дополнительные возможности

* Градиенты: Pygame не поддерживает их из коробки, но их можно создать, заполняя поверхность линиями или прямоугольниками.
* Прозрачность: Можно использовать Surface.set_alpha() для установки уровня прозрачности.

### 1.7. Цвет:

В Pygame цвета задаются с использованием цветовых моделей, наиболее популярной из которых является модель RGB (Red, Green, Blue). Цвет задаётся в виде кортежа из трёх чисел (R, G, B) или четырёх чисел (R, G, B, A) для включения прозрачности.

1) Цвет в формате RGB
Кортеж из трёх чисел, каждое из которых варьируется от 0 до 255:

(R, G, B)
 * R — интенсивность красного (Red).
 * G — интенсивность зелёного (Green).
 * B — интенсивность синего (Blue).
Примеры:

```python
WHITE = (255, 255, 255)  # Белый
BLACK = (0, 0, 0)        # Чёрный
RED = (255, 0, 0)        # Красный
GREEN = (0, 255, 0)      # Зелёный
BLUE = (0, 0, 255)       # Синий
```

2) Прозрачность (RGBA)
Если требуется использовать прозрачность, добавляется четвёртое число A (Alpha), которое определяет уровень прозрачности:

 * 0 — полностью прозрачный.
 * 255 — полностью непрозрачный.
Пример:

`TRANSPARENT_RED = (255, 0, 0, 128)  # Полупрозрачный красный`
Чтобы использовать прозрачность, объект Surface должен поддерживать per-pixel alpha:

```python
surface = pygame.Surface((100, 100), pygame.SRCALPHA)
pygame.draw.rect(surface, (255, 0, 0, 128), (0, 0, 100, 100))  # Прямоугольник с прозрачностью
```

3) Использование встроенных констант
В Pygame уже предопределены некоторые популярные цвета в модуле pygame.Color. Например:

```python
from pygame import Color

WHITE = Color('white')
RED = Color('red')
BLUE = Color('blue')
```

Это позволяет использовать названия цветов вместо чисел.

4) Примеры работы с цветами
Заливка фона:

```python
screen.fill((0, 128, 255))  # Заливка голубым цветом
```

Рисование с цветом:

```python
pygame.draw.rect(screen, (255, 255, 0), (50, 50, 200, 100))  # Жёлтый прямоугольник
pygame.draw.circle(screen, (128, 0, 128), (300, 300), 50)    # Фиолетовый круг
```

Использование прозрачности:

```python
surface = pygame.Surface((200, 200), pygame.SRCALPHA)  # Поверхность с поддержкой прозрачности
surface.fill((255, 0, 0, 128))  # Полупрозрачный красный квадрат
screen.blit(surface, (100, 100))
```

### 1.8. Пример простого цикла:

```python
import pygame

pygame.init()
screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption("Моя Первая Игра")

running = True

while running:
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      running = False

  # Заполняем экран белым цветом
  screen.fill((255, 255, 255)) 

  # Рисуем красный квадрат
  pygame.draw.rect(screen, (255, 0, 0), (100, 100, 50, 50))

  # Обновляем экран
  pygame.display.flip()

pygame.quit()
```

Этот код создает белое окно с красным квадратом в центре. 

### 1.9. Завершение работы:

В конце цикла игры нам нужно закрыть Pygame с помощью функции pygame.quit():

```python
pygame.quit()
```

### Заключение:
В этой главе мы познакомились с базовыми элементами Pygame: инициализацией, созданием окна, обработкой событий, отрисовкой графики. Эти знания помогут вам создавать простые игры и постепенно переходить к более сложным проектам.
